package easy;
import java.util.Deque;

import javax.swing.plaf.basic.BasicInternalFrameTitlePane.IconifyAction;

class TreeNode {
		     int val;
		     TreeNode left;
		     TreeNode right;
		     TreeNode() {}
		     TreeNode(int val) { this.val = val; }
		     TreeNode(int val, TreeNode left, TreeNode right) {
		     this.val = val;
		     this.left = left;
		     this.right = right;
		    }
		 }
public class T700 {
	/*
	 * 二叉树中的搜索 
	 * 给定一个BST的根节点和一个值，返回值为给定值的节点。否则为null 
	 * 二叉搜索树特点：左<根<右
	 * 因此二叉搜索树的搜索和普通二叉树是不同的。
	 */
	public static void main(String[] args) {
		TreeNode root=new TreeNode(4);
		TreeNode L1=new TreeNode(2);
		TreeNode L2=new TreeNode(1);
		TreeNode R1=new TreeNode(7);
		TreeNode R2=new TreeNode(3);
		root.left=L1;
		root.right=R1;
		L1.left=L2;
		L1.right=R2;
		
		//Deque<E>
		// 6  3 1 7
			
		show(root);
		
		//System.out.println(searchBST(root, 3).val);
	}
	public static TreeNode searchBST(TreeNode root, int val) {
		if(root==null||root.val==val)return root;
		return root.val>val ? searchBST(root.left, val) : searchBST(root.right, val);
    }
	
	
	//二叉树树的可视化  Test部分
  	public static void show(TreeNode root) {
          if (root == null){
              System.out.println("EMPTY!");
              return;
          }
          // 得到树的深度
          int treeDepth = getTreeDepth(root);

          // 最后一行的宽度为2的（n - 1）次方乘3，再加1
          // 作为整个二维数组的宽度
          int arrayHeight = treeDepth * 2 - 1;
          int arrayWidth = (2 << (treeDepth - 2)) * 3 + 1;
          // 用一个字符串数组来存储每个位置应显示的元素
          String[][] res = new String[arrayHeight][arrayWidth];
          // 对数组进行初始化，默认为一个空格
          for (int i = 0; i < arrayHeight; i++) {
              for (int j = 0; j < arrayWidth; j++) {
                  res[i][j] = " ";
              }
          }

          // 从根节点开始，递归处理整个树
          // res[0][(arrayWidth + 1)/ 2] = (char)(root.val + '0');
          writeArray(root, 0, arrayWidth / 2, res, treeDepth);

          // 此时，已经将所有需要显示的元素储存到了二维数组中，将其拼接并打印即可
          for (String[] line : res) {
              StringBuilder sb = new StringBuilder();
              for (int i = 0; i < line.length; i++) {
                  sb.append(line[i]);
                  if (line[i].length() > 1 && i <= line.length - 1) {
                      i += line[i].length() > 4 ? 2 : line[i].length() - 1;
                  }
              }
              System.out.println(sb.toString());
          }
  	}
          
          
          private static void writeArray(TreeNode currNode, int rowIndex, int columnIndex, String[][] res, int treeDepth) {
              // 保证输入的树不为空
              if (currNode == null) return;
              // 先将当前节点保存到二维数组中
              res[rowIndex][columnIndex] = String.valueOf(currNode.val);
              // 计算当前位于树的第几层
              int currLevel = ((rowIndex + 1) / 2);
              // 若到了最后一层，则返回
              if (currLevel == treeDepth) return;
              // 计算当前行到下一行，每个元素之间的间隔（下一行的列索引与当前元素的列索引之间的间隔）
              int gap = treeDepth - currLevel - 1;

              // 对左儿子进行判断，若有左儿子，则记录相应的"/"与左儿子的值
              if (currNode.left != null) {
                  res[rowIndex + 1][columnIndex - gap] = "/";
                  writeArray(currNode.left, rowIndex + 2, columnIndex - gap * 2, res, treeDepth);
              }
 
              // 对右儿子进行判断，若有右儿子，则记录相应的"\"与右儿子的值
              if (currNode.right != null) {
                  res[rowIndex + 1][columnIndex + gap] = "\\";
                  writeArray(currNode.right, rowIndex + 2, columnIndex + gap * 2, res, treeDepth);
              }
          }
          
          private static int getTreeDepth(TreeNode root) {
              return root == null ? 0 : (1 + Math.max(getTreeDepth(root.left), getTreeDepth(root.right)));
          }
			
		
		    
	
		 

}
